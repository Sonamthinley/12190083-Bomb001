Use 'objdump -d bomb' to check the assembly code for phase 2.

lab2@lab2-OptiPlex-3040:~/Desktop/12190083/Assignment/bomb001$ objdump -d bomb

0000000000400ea9 <phase_2>:
  400ea9:	55                   	push   %rbp
  400eaa:	53                   	push   %rbx
  400eab:	48 83 ec 28          	sub    $0x28,%rsp
  400eaf:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  400eb6:	00 00 
  400eb8:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  400ebd:	31 c0                	xor    %eax,%eax
  400ebf:	48 89 e6             	mov    %rsp,%rsi
  400ec2:	e8 98 05 00 00       	callq  40145f <read_six_numbers>   //This Phase wants input of six integers
  400ec7:	83 3c 24 00          	cmpl   $0x0,(%rsp)
  400ecb:	75 07                	jne    400ed4 <phase_2+0x2b>
  400ecd:	83 7c 24 04 01       	cmpl   $0x1,0x4(%rsp)
  400ed2:	74 05                	je     400ed9 <phase_2+0x30>
  400ed4:	e8 64 05 00 00       	callq  40143d <explode_bomb>
  400ed9:	48 89 e3             	mov    %rsp,%rbx
  400edc:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
  400ee1:	8b 43 04             	mov    0x4(%rbx),%eax
  400ee4:	03 03                	add    (%rbx),%eax
  400ee6:	39 43 08             	cmp    %eax,0x8(%rbx)
  400ee9:	74 05                	je     400ef0 <phase_2+0x47>
  400eeb:	e8 4d 05 00 00       	callq  40143d <explode_bomb>
  400ef0:	48 83 c3 04          	add    $0x4,%rbx
  400ef4:	48 39 eb             	cmp    %rbp,%rbx
  400ef7:	75 e8                	jne    400ee1 <phase_2+0x38>
  400ef9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  400efe:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  400f05:	00 00 
  400f07:	74 05                	je     400f0e <phase_2+0x65>
  400f09:	e8 f2 fb ff ff       	callq  400b00 <__stack_chk_fail@plt>
  400f0e:	48 83 c4 28          	add    $0x28,%rsp
  400f12:	5b                   	pop    %rbx
  400f13:	5d                   	pop    %rbp
  400f14:	c3                   	retq 
  
  For our Test input, we will give values "0 1 2 3 4 5" and diassemble our program
 
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Phase 1 defused. How about the next one?
  0 1 2 3 4 5
  Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
  (gdb) disas
  Dump of assembler code for function phase_2:
  => 0x0000000000400ea9 <+0>:	push   %rbp
     0x0000000000400eaa <+1>:	push   %rbx
     0x0000000000400eab <+2>:	sub    $0x28,%rsp
     0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
     0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
     0x0000000000400ebd <+20>:	xor    %eax,%eax
     0x0000000000400ebf <+22>:	mov    %rsp,%rsi
     0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
     0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)                   
     0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
     0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
     0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
     0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
     0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
     0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
     0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
     0x0000000000400ee4 <+59>:	add    (%rbx),%eax
     0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
     0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
     0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
     0x0000000000400ef0 <+71>:	add    $0x4,%rbx
     0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
     0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
     0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
     0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
     0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
     0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
     0x0000000000400f0e <+101>:	add    $0x28,%rsp
     0x0000000000400f12 <+105>:	pop    %rbx
     0x0000000000400f13 <+106>:	pop    %rbp
     0x0000000000400f14 <+107>:	retq   
  End of assembler dump.
  
  Lets check at what our cmpl statement is comparing
  (gdb) u *0x0000000000400ec7
0x0000000000400ec7 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
=> 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.

(gdb) i r
rax            0x6	6
rbx            0x7fffffffde68	140737488346728
rcx            0x0	0
rdx            0x7fffffffdd54	140737488346452
rsi            0x0	0
rdi            0x7fffffffd6b0	140737488344752
rbp            0x4021f0	0x4021f0 <__libc_csu_init>
rsp            0x7fffffffdd40	0x7fffffffdd40
r8             0x0	0
r9             0x0	0
r10            0x7ffff7b80c40	140737349422144
r11            0x4025d4	4203988
r12            0x400c60	4197472
r13            0x7fffffffde60	140737488346720
r14            0x0	0
r15            0x0	0
rip            0x400ec7	0x400ec7 <phase_2+30>
eflags         0x202	[ IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

(gdb) x /d0x7fffffffdd40
0x7fffffffdd40:	0

Since the value of %rsp is 0, we can jump the bomb.
Now, look at the next compare statement and see what is being compared.

(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
=> 0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
We have to check if the value of %rsp is equal to 1.
(gdb) i r
rax            0x6	6
rbx            0x7fffffffde68	140737488346728
rcx            0x0	0
rdx            0x7fffffffdd54	140737488346452
rsi            0x0	0
rdi            0x7fffffffd6b0	140737488344752
rbp            0x4021f0	0x4021f0 <__libc_csu_init>
rsp            0x7fffffffdd40	0x7fffffffdd40
r8             0x0	0

(gdb) x /2d0x7fffffffdd40
0x7fffffffdd40:	0	1
Since the value of %rsp is 1, we can jump the bomb.

Now, We check the next compare statement
(gdb) u *0x0000000000400ee6
0x0000000000400ee6 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
=> 0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.

We see that %eax and %rbx are being compared.

(gdb) i r
rax            0x1	1
rbx            0x7fffffffdd40	140737488346432
rcx            0x0	0
rdx            0x7fffffffdd54	140737488346452
rsi            0x0	0
rdi            0x7fffffffd6b0	140737488344752
rbp            0x7fffffffdd50	0x7fffffffdd50

(gdb) x /d0x7fffffffdd40
0x7fffffffdd40:	0

Since %eax is not equal to %rbx, the bomb will be exploded.
(gdb) ni
0x0000000000400ee9 in phase_2 ()
(gdb) ni
0x0000000000400eeb in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
=> 0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) ni

BOOM!!!
The bomb has blown up.
[Inferior 1 (process 3646) exited with code 010]

We need to again see the compare statement after the bomb explosion is called.

(gdb) u *0x0000000000400ef4
0x0000000000400ef4 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
=> 0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   
   we see that %rbp is being compared to %rbx, check their values
   
   (gdb) i r
  rax            0x1	1
  rbx            0x7fffffffdd44	140737488346436
  rcx            0x0	0
  rdx            0x7fffffffdd54	140737488346452
  rsi            0x0	0
  rdi            0x7fffffffd6b0	140737488344752
  rbp            0x7fffffffdd50	0x7fffffffdd50
  rsp            0x7fffffffdd40	0x7fffffffdd40

   (gdb) x /d0x7fffffffdd50
   0x7fffffffdd50:	4
   (gdb) x /d0x7fffffffdd44
   0x7fffffffdd44:	1







 






  
  
 
